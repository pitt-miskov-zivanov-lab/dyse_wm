import sys
import re
import csv
import math
import os
import subprocess
import argparse
import logging
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from Sensitivity.Pathway_Analysis.weighted_directed_network import WDN_Model
from Sensitivity.Pathway_Analysis.extract_pathways import EXTRACT_PATHS
from Sensitivity.Pathway_Analysis.hybrid_discrete import generate_discrete_sa


def run_static(rules_file, output_file, framework_path):
	"""
	Run static sensitivity analysis for boolean model, write output to file

	Inputs:
		rules_file: .txt model rules generated by simulator_interface
		[remember to make sure that all element levels are 2 before generating rules]
		output_file: file to write output of static sensitivity analysis
		framework_path: relative path to framework top level directory
	"""

	# executable path
	start_dir = os.getcwd()
	framework_dir = os.path.join(start_dir,framework_path)
	static_path_str = os.path.join(framework_dir,'Sensitivity','Static','analysis')

	# call static analysis executable in a subprocess
	output_file = open(output_file, 'w')
	p = subprocess.Popen(
			[static_path_str,
            rules_file],
			stdout=output_file,
			stderr=subprocess.PIPE,
			universal_newlines=True
			)

	p.wait()

	if p.returncode != 0:
		error = p.communicate()[1]
		raise ValueError(
				'Error in sensitivity analysis: Return Code {} \n {}'.format(
				p.returncode, error
				))

def run_dynamic(trace_file, static_file, output_file, framework_path):
	"""
	Run dynamic sensitivity analysis for boolean model, write output to file

	Inputs:
		[remember to make sure that all element levels are 2]
		static_file: result file from static analysis via run_static()
		trace_file: .txt trace files generated by simulator_interface
		output_file: file to write output of dynamic sensitivity analysis
		framework_path: relative path to framework top level directory
	"""

	# executable path
	start_dir = os.getcwd()
	framework_dir = os.path.join(start_dir,framework_path)
	dynamic_path_str = os.path.join(framework_dir,'Sensitivity','Dynamic','DyAnalysis')

	# call dynamic analysis executable in a subprocess
	p = subprocess.Popen(
			[dynamic_path_str,
			trace_file,
			static_file,
			output_file],
			stdout=subprocess.PIPE,
			stderr=subprocess.PIPE,
			universal_newlines=True
			)

	p.wait()

	if p.returncode != 0:
		error = p.communicate()[1]
		raise ValueError(
				'Error in sensitivity analysis: Return Code {} \n {}'.format(
				p.returncode, error
				))

def run_discrete_static(model_excel, output_file, method, status_report):

	"""
	Run discrete static sensitivity analysis, write output to file

	Inputs:
		model_excel: .xlsx model files
		output_file: file to write output of sensitivity analysis
		method: choose from 'FB' or 'HB', the former is faster, the latter is more accurate
		status_report: choose from True or False, whether to report current analysis percentage
	"""
	# run discrete static analysis
	Norm = True
	LoSe = True
	trace_file = None

	generate_discrete_sa(model_excel, output_file, method, status_report, Norm, LoSe, trace_file)


def run_discrete_dynamic(model_excel, trace_file, output_file, method, status_report):

	"""
	Run discrete dynamic sensitivity analysis, write output to file

	Inputs:
		model_excel: .xlsx model files
		trace_file: .txt trace files generated by simulator_interface
		output_file: file to write output of sensitivity analysis
		method: choose from 'FB' or 'HB', the former is faster, the latter is more accurate
		status_report: choose from True or False, whether to report current analysis percentage

	"""
	# run discrete dynamic analysis
	Norm = True
	LoSe = True
	trace_file_name = trace_file
	generate_discrete_sa(model_excel, output_file, method, status_report, Norm, LoSe, trace_file_name)

def get_element_list(model):
	return model.element_list()

def get_element_sensitivity(model):
	return model.element_sensitivity_list()

def get_element_immediate_influence(model):
	return model.immediate_influence_matrix()

def get_element_to_element_influence(model, status_report):
	return model.ETEI_matrix(status_report)

# Save the sorted element list for reference, all the following analysis results follow this sorted order
def save_element_list(model, dire):
	f_out = open(dire+'/alpha_sorted_element.txt','w')
	for row in get_element_list(model):
		f_out.write(str(row)+',\n')

# Save the element sensitivity values into a .txt file, see technical details at https://arxiv.org/abs/1902.03216 , Section 3.2
def save_element_sensitivity(model, dire):
	f_out = open(dire+'/alpha_sorted_element_sensitivity.txt','w')
	for row in get_element_sensitivity(model):
		f_out.write(str(row)+',\n')

# Save the immediate element influence matrix into a .txt file, see technical details at https://arxiv.org/abs/1902.03216 , Section 3.1
def save_element_immediate_influence(model, dire):
	f_out = open(dire+'/immediate_element_influence.txt','w')
	for row in get_element_immediate_influence(model):
		for i in row:
			f_out.write(str(i)+',')
		f_out.write('\n')

# Save the ETEI matrix into a .txt file, see technical details at https://arxiv.org/abs/1902.03216 , Section 5.4
def save_element_to_element_influence(model, dire):
	f_out = open(dire+'/element_to_element_influence.txt','w')
	for row in get_element_to_element_influence(model):
		for i in row:
			f_out.write(str(i)+',')
		f_out.write('\n')

# Plot the element sensitivity values
def plot_element_sensitivity(model, dire):
	data = get_element_sensitivity(model)
	data_label = get_element_list(model)
	figure_title = 'Element Sensitivity'
	save_location = dire+'/alpha_sorted_element_sensitivity.png'
	plot_bar(data, data_label, figure_title, save_location)

# Plot the immediate element influence matrix in heatmap
def plot_element_immediate_influence(model, dire):
	data = get_element_immediate_influence(model)
	xlabel = get_element_list(model)
	ylabel = get_element_list(model)
	figure_title = 'Element immediate influence matrix'
	save_location = dire+'/immediate_element_influence.png'
	plot_matrix(data, xlabel, ylabel, figure_title, save_location)

# Plot the ETEI matrix in heatmap
def plot_element_to_element_influence(model, dire):
	data = get_element_to_element_influence(model)
	xlabel = get_element_list(model)
	ylabel = get_element_list(model)
	figure_title = 'ETEI matrix'
	save_location = dire+'/element_to_element_influence.png'
	plot_matrix(data, xlabel, ylabel, figure_title, save_location)

# Two sub functions that are used to plot figures
def plot_bar(data, data_label, figure_title, save_location):
	plt.bar(range(len(data_label)), data, align='center')
	plt.xticks(range(len(data_label)), data_label, rotation='vertical', fontsize='7')
	plt.title(figure_title)
	plt.ylabel('Value')
	plt.tight_layout()
	figure = plt.gcf()
	figure.set_size_inches(8, 6)
	plt.savefig(save_location, dpi=150)

def plot_matrix(data, xlabel, ylabel, figure_title, save_location):
	fig, ax = plt.subplots()
	im = ax.imshow(data, cmap="Blues")
	fig.colorbar(im, ax=ax)
	ax.set_xticks(np.arange(len(xlabel)))
	ax.set_yticks(np.arange(len(ylabel)))
	ax.set_xticklabels(xlabel)
	ax.set_yticklabels(ylabel)
	ax.set_xlabel('Target element')
	ax.set_ylabel('Source element')
	ax.set_title(figure_title)
	plt.setp(ax.get_xticklabels(), rotation=90, fontsize='7')
	plt.setp(ax.get_yticklabels(), fontsize='7')
	fig.tight_layout()
	plt.gcf().set_size_inches(10, 10)
	plt.savefig(save_location, dpi=150)

# return the index of inquiry element
def inquire_element_index(element, model):
	try:
		ind = get_element_list(model).index(element)
	except:
		logging.warning('\n This element is not in the model')
		sys.exit(1)
	return ind

# return the sensitivity of inquiry element
def inquire_element_sensitivity(element, model):
	return model.element_sensitivity(element)

# return the immediate influence from element1 to element2
def inquire_element_immediate_influence_from_to(element1, element2, model):
	return model.element_immediate_influence_from_to(element1, element2)

# return the immediate influce of the inquiry element on other elements
def inquire_element_immediate_influence_from(element, model):
	return model.element_immediate_influence_from(element)

# return the immediate influce of other elements on the inquiry element
def inquire_element_immediate_influence_to(element, model):
	return model.element_immediate_influence_to(element)

# return the ETEI from element1 to element2
def inquire_ETEI_from_to(element1, element2, model):
	return model.ETEI_from_to(element1, element2)

# return the ETEI of the inquiry element on other elements
def inquire_ETEI_from(element, model):
	return model.ETEI_from(element)

# return the ETEI of other elements on the inquiry element
def inquire_ETEI_to(element, model):
	return model.ETEI_to(element)

# return the top n paths from source to target in the criterion of att
def top_n_paths_from_to(source, target, n, atts, model):
	source = source.split('&')
	target = target.split('&')
	atts = atts.split('&')

	my_dict = model.alpha_dict
	res_dict = {}
	for s in source:
		for t in target:
			if (s not in get_element_list(model)) or (t not in get_element_list(model)):
				logging.warning('\n Some of your inquiry elements is/are not in the model')
				sys.exit(1)
			#N_all_active_paths = len([x for x in model.bfs_paths(t,s) if model.path_score(x) != float('-inf')])
			N_all_active_paths = 100
			if N_all_active_paths == 0:
				logging.warning('\n There is no active pathways from {source} to {target}'.format(source=s, target=t))
				sys.exit(1)
			num = n
			if n > N_all_active_paths:
				logging.warning('\n Your inquiry number of pathways from {res1} to {res2} is greater than the number of all active pathways: {res3}'.format(res1=s, res2=t, res3=N_all_active_paths))
				logging.warning('\n Only {res4} active pathway(s) for this source-target pair will be returned'.format(res4=N_all_active_paths))
				num = N_all_active_paths
			for att in atts:
				G = EXTRACT_PATHS.CreateGraph(my_dict)
				pos = EXTRACT_PATHS.DrawPath(G, s, t, att)
				#top_n_paths, priority_list = EXTRACT_PATHS.aStarSearch(G, s, t, pos, att, num)
				top_n_paths, priority_list = EXTRACT_PATHS.YenKSearch(G, s, t, att, num)
				top_n_paths = [','.join(top_n_paths[i]) for i in range(len(top_n_paths))]
				key = '{source} to {target} in {attribute} criterion'.format(source=s, target=t, attribute=att)
				value = dict(zip(top_n_paths, priority_list))
				res_dict[key] = value

	return res_dict

# This main function is an interface to reformat raw outcomes from WDN_Model().parse_static/dynamic into more organized text results and plots
def main():

	# set up logging to stdout
	log_formatter = logging.Formatter("%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s]  %(message)s")
	log_handler = logging.StreamHandler(sys.stdout)
	log_handler.setFormatter(log_formatter)
	logger = logging.getLogger()
	logger.addHandler(log_handler)
	logger.setLevel(logging.INFO)

	# Construct the argument parser
	ap = argparse.ArgumentParser()

	# Add the arguments to the parser
	ap.add_argument("-l", "--label", required=True, choices=['static','dynamic'],
	   help="which type of analysis is running, usage: -l 'static' or -l 'dynamic'")
	ap.add_argument("-i", "--input_file", required=True,
	   help="the directory of input raw sensitivity file")
	ap.add_argument("-o", "--output_folder", required=True,
	   help="the directory folder where the analysis results will be stored")
	ap.add_argument("-a", "--all", required=False,
	   help="run analysis for all elements, default usage: -a 'ALL'")
	ap.add_argument("-e", "--inquiry_element", required=False,
	   help="find the sensitivity and influence values for this inquiry element, usage:-e ELEMENTNAME")
	ap.add_argument("-p", "--extract_pathways", required=False,
	   help="find the desired pathways, usage:-p 'SOURCENAME,TARGETNAME,ATTCHOICE,NUM', \
	   commas are used to seperate these four mandatory parameters, no space is allowed:\
	   SOURCENAME can be single or multiple with '&' seperated,\
	   TARGETNAME can be single or multiple with '&' seperated,\
	   choose ATTCHOICE from {'sensi', 'influ', 'sensi & influ'},\
	   NUM is int number of desired pathways")


	args = vars(ap.parse_args())

	f = open(args['input_file'],'r')
	model = WDN_Model()
	MODELNAME = args['output_folder']

	# Parse an indicator to decide to analyze in a static or dynamic fashion
	# More options will be available later, e.g., another indicator to decide whether to analyze in a Boolean or discrete fashion
	if args['label'] == 'static':
		model.parse_static(f)
		dire = MODELNAME + '_more_static_SA_results'
		logging.info("Begin static sensitivity analysis")
	else:
		model.parse_dynamic(f)
		dire = MODELNAME + '_more_dynamic_SA_results'
		logging.info("Begin dynamic sensitivity analysis")

	if not os.path.exists(dire):
		os.makedirs(dire)

	if args['all'] is not None:
		#return all relevant results and plot all relevant figures
		save_element_list(model, dire)

		save_element_sensitivity(model, dire)
		logging.info("Done with element sensitivities")
		plot_element_sensitivity(model, dire)
		logging.info("Plot element_sensitivity.png saved")

		save_element_immediate_influence(model, dire)
		logging.info("Done with immediate element influence")
		plot_element_immediate_influence(model, dire)
		logging.info("Plot immediate_element_influence.png saved")

		save_element_to_element_influence(model, dire)
		logging.info("Done with element to element influence")
		plot_element_to_element_influence(model, dire)
		logging.info("Plot element_to_element_influence.png saved")


	if args['inquiry_element'] is not None:
		#User input inquiries to explore sensitivity and influence values here
		element = args['inquiry_element']

		res1 = inquire_element_sensitivity(element, model)
		res2 = inquire_element_immediate_influence_from(element, model)
		res3 = inquire_element_immediate_influence_to(element, model)
		res4 = inquire_ETEI_from(element, model)
		res5 = inquire_ETEI_to(element, model)

		f_out = open(dire+'/inquiry_results.txt','w')
		f_out.write('{name}:\n'.format(name=element))
		f_out.write('The sensitivity value of the inquiry element is:\n {res1} \n\n'.format(res1=res1))
		f_out.write('The immediate element influence of the inquiry element on the following elements are \
		(if empty/zero, it indicates the inquiry element does not regulate others):\n {res2} \n\n'.format(res2=str(res2)))
		f_out.write('The immediate element influence of the following elements on the inquiry element are \
		(if empty/zero, it indicates the inquiry element is an input element and not regulated by other elements):\n {res3} \n\n'.format(res3=str(res3)))
		f_out.write('The ETEI of the inquiry element on the following elements are \
		(if empty/zero, it indicates the inquiry element does not regulate other elements in any path): \n {res4} \n\n'.format(res4=str(res4)))
		f_out.write('The ETEI of the following elements on the inquiry element are \
		(if empty/zero, it indicates the inquiry element is not regulated by other elements in any path): \n {res5} \n\n'.format(res5=str(res5)))
		f_out.close()
		logging.info('Relevant results of inquiry element are ready.')

	if args['extract_pathways'] is not None:

		parsing = str(args['extract_pathways']).replace(" ", "").split(',')
		inquiry_source = parsing[0]
		inquiry_target = parsing[1]
		inquiry_attribute = parsing[2]
		number_of_desired_pathways = int(parsing[3])

		with open(dire+'/top_pathways.csv', 'w', newline='') as file:
			writer = csv.writer(file)
			for key, value in top_n_paths_from_to(inquiry_source, inquiry_target, number_of_desired_pathways, inquiry_attribute, model).items():
				writer.writerow([key,]+list(value.items()))
		logging.info('Pathways extractions are ready.')

if __name__=="__main__":
	main()
